{"version":3,"file":"model.js","sourceRoot":"","sources":["../../../../packages/forms/src/model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from './directives/validators';\nimport {toObservable} from './validators';\n\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = (<string>path).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return (<Array<string|number>>path).reduce((v: AbstractControl, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls.hasOwnProperty(name as string) ? v.controls[name] : null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at(<number>name) || null;\n    }\n\n    return null;\n  }, control);\n}\n\nfunction coerceToValidator(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): ValidatorFn|\n    null {\n  const validator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).validators :\n                                       validatorOrOpts) as ValidatorFn |\n      ValidatorFn[] | null;\n\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\nfunction coerceToAsyncValidator(\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null, validatorOrOpts?: ValidatorFn |\n        ValidatorFn[] | AbstractControlOptions | null): AsyncValidatorFn|null {\n  const origAsyncValidator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).asyncValidators :\n                                       asyncValidator) as AsyncValidatorFn |\n      AsyncValidatorFn | null;\n\n  return Array.isArray(origAsyncValidator) ? composeAsyncValidators(origAsyncValidator) :\n                                             origAsyncValidator || null;\n}\n\nexport type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport interface AbstractControlOptions {\n  /**\n   * List of validators applied to control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * List of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\n\nfunction isOptionsObj(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): boolean {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingDirty !: boolean;\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingTouched !: boolean;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _updateOn !: FormHooks;\n\n  // TODO(issue/24571): remove '!'.\n  private _parent !: FormGroup | FormArray;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For a `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value: any;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validator The function that determines the synchronous validity of this control.\n   * @param asyncValidator The function that determines the asynchronous validity of this\n   * control.\n   */\n  constructor(public validator: ValidatorFn|null, public asyncValidator: AsyncValidatorFn|null) {}\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray { return this._parent; }\n\n  /**\n   * The validation status of the control. There are four possible\n   * validation status values:\n   *\n   * * **VALID**: This control has passed all validation checks.\n   * * **INVALID**: This control has failed at least one validation check.\n   * * **PENDING**: This control is in the midst of conducting a validation check.\n   * * **DISABLED**: This control is exempt from validation checks.\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly status !: string;\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean { return this.status === VALID; }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean { return this.status === INVALID; }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean { return this.status == PENDING; }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * @see `status`\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean { return this.status === DISABLED; }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   */\n  get enabled(): boolean { return this.status !== DISABLED; }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly errors !: ValidationErrors | null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  public readonly pristine: boolean = true;\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean { return !this.pristine; }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  public readonly touched: boolean = false;\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean { return !this.touched; }\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly valueChanges !: Observable<any>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly statusChanges !: Observable<any>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn|ValidatorFn[]|null): void {\n    this.validator = coerceToValidator(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n\n  /**\n   * Empties out the sync validator list.\n   */\n  clearValidators(): void { this.validator = null; }\n\n  /**\n   * Empties out the async validator list.\n   */\n  clearAsyncValidators(): void { this.asyncValidator = null; }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value; compare `markAsDirty`;\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild(\n        (control: AbstractControl) => { control.markAsUntouched({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's is changed through the UI; compare `markAsTouched`.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsDirty(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   *  @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   */\n  markAsPristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild((control: AbstractControl) => { control.markAsPristine({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      (this.statusChanges as EventEmitter<any>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   *  @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = DISABLED;\n    (this as{errors: ValidationErrors | null}).errors = null;\n    this._forEachChild(\n        (control: AbstractControl) => { control.disable({...opts, onlySelf: true}); });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   *  @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = VALID;\n    this._forEachChild(\n        (control: AbstractControl) => { control.enable({...opts, onlySelf: true}); });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(opts: {onlySelf?: boolean, emitEvent?: boolean}) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n\n  /**\n   * @param parent Sets the parent of the control\n   */\n  setParent(parent: FormGroup|FormArray): void { this._parent = parent; }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: any, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: any, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: any, options?: Object): void;\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      (this as{errors: ValidationErrors | null}).errors = this._runValidator();\n      (this as{status: string}).status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    (this as{status: string}).status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors|null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      (this as{status: string}).status = PENDING;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription =\n          obs.subscribe((errors: ValidationErrors | null) => this.setErrors(errors, {emitEvent}));\n    }\n  }\n\n  private _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @usageNotes\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {\n    (this as{errors: ValidationErrors | null}).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name']);`\n   */\n  get(path: Array<string|number>|string): AbstractControl|null { return _find(this, path, '.'); }\n\n  /**\n   * Reports error data for a specific error occurring in this control or in another control.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   *\n   * @returns The error data if the control with the given path has the given error, otherwise null\n   * or undefined.\n   */\n  getError(errorCode: string, path?: string[]): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   * @returns True when the control with the given path has the error, otherwise false.\n   */\n  hasError(errorCode: string, path?: string[]): boolean { return !!this.getError(errorCode, path); }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(emitEvent: boolean): void {\n    (this as{status: string}).status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    (this as{valueChanges: Observable<any>}).valueChanges = new EventEmitter();\n    (this as{statusChanges: Observable<any>}).statusChanges = new EventEmitter();\n  }\n\n\n  private _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: Function): void;\n\n  /** @internal */\n  abstract _anyControls(condition: Function): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n\n  /** @internal */\n  _isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void { this._onCollectionChange = fn; }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {\n    if (isOptionsObj(opts) && (opts as AbstractControlOptions).updateOn != null) {\n      this._updateOn = (opts as AbstractControlOptions).updateOn !;\n    }\n  }\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the three fundamental building blocks of Angular forms, along with\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n *```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a sync validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to an initial value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n *\n * @publicApi\n */\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n\n  /** @internal */\n  _pendingValue: any;\n\n  /** @internal */\n  _pendingChange: any;\n\n  /**\n  * Creates a new `FormControl` instance.\n  *\n  * @param formState Initializes the control with an initial value,\n  * or an object that defines the initial value and disabled state.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      formState: any = null,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n    this._initObservables();\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control proopagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    (this as{value: any}).value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(\n          (changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see `setValue` for options\n   */\n  patchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(formState: any = null, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n\n  /**\n   * @internal\n   */\n  _updateValue() {}\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: Function): boolean { return false; }\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean { return this.disabled; }\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void { this._onChange.push(fn); }\n\n  /**\n   * @internal\n   */\n  _clearChangeFns(): void {\n    this._onChange = [];\n    this._onDisabledChange = [];\n    this._onCollectionChange = () => {};\n  }\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: Function): void {}\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      (this as{value: any}).value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      (this as{value: any}).value = this._pendingValue = formState;\n    }\n  }\n}\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * @publicApi\n */\nexport class FormGroup extends AbstractControl {\n  /**\n  * Creates a new `FormGroup` instance.\n  *\n  * @param controls A collection of child controls. The key for each child is the name\n  * under which it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: {[key: string]: AbstractControl},\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param name The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you excluding the value of a control.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n   * console.log(this.form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  reset(value: any = {}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : (<any>control).getRawValue();\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(k => cb(this.controls[k], k));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  _updateValue(): void { (this as{value: any}).value = this._reduceValue(); }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    let res = false;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n\n  /** @internal */\n  _reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _reduceChildren(initValue: any, fn: Function) {\n    let res = initValue;\n    this._forEachChild(\n        (control: AbstractControl, name: string) => { res = fn(res, control, name); });\n    return res;\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n  * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport class FormArray extends AbstractControl {\n  /**\n  * Creates a new `FormArray` instance.\n  *\n  * @param controls An array of child controls. Each child control is given an index\n  * where it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: AbstractControl[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number): AbstractControl { return this.controls[index]; }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control\n   */\n  removeAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The `AbstractControl` control to replace the existing control\n   */\n  setControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   */\n  get length(): number { return this.controls.length; }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  setValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * this.arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * console.log(this.arr.get(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  reset(value: any = [], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : (<any>control).getRawValue();\n    });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this.controls.reduce((updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => { cb(control, index); });\n  }\n\n  /** @internal */\n  _updateValue(): void {\n    (this as{value: any}).value =\n        this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n  }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  private _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n"]}